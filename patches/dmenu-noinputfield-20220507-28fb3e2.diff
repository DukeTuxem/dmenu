From c8c07533f68e8e51686418a6a2984053a5bb7255 Mon Sep 17 00:00:00 2001
From: Duke Tuxem <33418846+DukeTuxem@users.noreply.github.com>
Date: Sat, 7 May 2022 15:57:28 +0200
Subject: [PATCH] A dmenu patch to disable the keyboard input field.

The added -x option prevents any character insertion or paste mode,
removing the cursor at the same time.

This is helpful to make a choice with a few items passed through stdin,
so one is not seeing them erased by typing anything on the keyboard.

A simple example could be a confirmation prompt:
$> printf "No\nYes" | dmenu -x -p "Do you want to exit ?"
---
 dmenu.1 |  4 ++++
 dmenu.c | 28 +++++++++++++++++-----------
 2 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/dmenu.1 b/dmenu.1
index 323f93c..aac4afa 100644
--- a/dmenu.1
+++ b/dmenu.1
@@ -80,6 +80,10 @@ prints version information to stdout, then exits.
 .TP
 .BI \-w " windowid"
 embed into windowid.
+.TP
+.BI \-x
+deactivate the keyboard input field. This is useful to create an interaction
+that does not require to type but to only select.
 .SH USAGE
 dmenu is completely controlled by the keyboard.  Items are selected using the
 arrow keys, page up, page down, home, and end.
diff --git a/dmenu.c b/dmenu.c
index 571bc35..5ceefea 100644
--- a/dmenu.c
+++ b/dmenu.c
@@ -44,6 +44,7 @@ static struct item *items = NULL;
 static struct item *matches, *matchend;
 static struct item *prev, *curr, *next, *sel;
 static int mon = -1, screen;
+static int inputfield = 1;
 
 static Atom clip, utf8;
 static Display *dpy;
@@ -158,14 +159,16 @@ drawmenu(void)
 		x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
 	}
 	/* draw input field */
-	w = (lines > 0 || !matches) ? mw - x : inputw;
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
-
-	curpos = TEXTW(text) - TEXTW(&text[cursor]);
-	if ((curpos += lrpad / 2 - 1) < w) {
+	if (inputfield) {
+		w = (lines > 0 || !matches) ? mw - x : inputw;
 		drw_setscheme(drw, scheme[SchemeNorm]);
-		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+
+		curpos = TEXTW(text) - TEXTW(&text[cursor]);
+		if ((curpos += lrpad / 2 - 1) < w) {
+			drw_setscheme(drw, scheme[SchemeNorm]);
+			drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
+		}
 	}
 
 	if (lines > 0) {
@@ -373,8 +376,9 @@ keypress(XKeyEvent *ev)
 			break;
 		case XK_y: /* paste selection */
 		case XK_Y:
-			XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
-			                  utf8, utf8, win, CurrentTime);
+			if (inputfield)
+				XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
+			                          utf8, utf8, win, CurrentTime);
 			return;
 		case XK_Left:
 		case XK_KP_Left:
@@ -415,7 +419,7 @@ keypress(XKeyEvent *ev)
 	switch(ksym) {
 	default:
 insert:
-		if (!iscntrl((unsigned char)*buf))
+		if (!iscntrl((unsigned char)*buf) && inputfield)
 			insert(buf, len);
 		break;
 	case XK_Delete:
@@ -515,7 +519,7 @@ insert:
 		}
 		break;
 	case XK_Tab:
-		if (!sel)
+		if (!sel || !inputfield)
 			return;
 		strncpy(text, sel->text, sizeof text - 1);
 		text[sizeof text - 1] = '\0';
@@ -730,6 +734,8 @@ main(int argc, char *argv[])
 			topbar = 0;
 		else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
 			fast = 1;
+		else if (!strcmp(argv[i], "-x"))   /* deactivates input field */
+			inputfield = 0;
 		else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
 			fstrncmp = strncasecmp;
 			fstrstr = cistrstr;
-- 
2.36.0

